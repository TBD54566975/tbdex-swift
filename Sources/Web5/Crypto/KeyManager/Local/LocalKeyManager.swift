import Foundation

public enum LocalKeyManagerError: Error {
    case unknownCryptoAlgorithm
    case asymmetricKeyGenerationNotSupported(algorithm: Algorithm)
    case signingNotSupported(algorithm: Algorithm)
    case keyNotFound
}

/// Protocol for a backing store which can store keys generated by a `LocalKeyManager`
public protocol LocalKeyStore {
    func getPrivateKey(keyAlias: String) throws -> Jwk?
    func setPrivateKey(_ privateKey: Jwk, keyAlias: String) throws
}

/// A KeyManager that generates and stores cryptographic keys locally on the device
public class LocalKeyManager: KeyManager {

    /// Backing store to store generated keys
    let keyStore: LocalKeyStore

    /// Default initializer
    init(keyStore: LocalKeyStore) {
        self.keyStore = keyStore
    }

    // MARK: - KeyManager

    public func generatePrivateKey(algorithm: Algorithm) throws -> String {
        guard let asymmetricKeyGenerator = algorithm.asymmetricKeyGenerator else {
            throw LocalKeyManagerError.asymmetricKeyGenerationNotSupported(algorithm: algorithm)
        }

        let privateKey = try asymmetricKeyGenerator.generatePrivateKey()
        let keyAlias = try getDeterministicAlias(key: privateKey)

        try keyStore.setPrivateKey(privateKey, keyAlias: keyAlias)

        return keyAlias
    }

    public func getPublicKey(keyAlias: String) throws -> Jwk {
        let privateKey = try getPrivateKey(keyAlias: keyAlias)
        let algorithm = try getSupportedCryptoAlgorithm(for: privateKey)

        guard let asymmetricKeyGenerator = algorithm.asymmetricKeyGenerator else {
            throw LocalKeyManagerError.asymmetricKeyGenerationNotSupported(algorithm: algorithm)
        }

        return try asymmetricKeyGenerator.computePublicKey(privateKey: privateKey)
    }

    public func sign<D>(keyAlias: String, payload: D) throws -> Data where D: DataProtocol {
        let privateKey = try getPrivateKey(keyAlias: keyAlias)
        let algorithm = try getSupportedCryptoAlgorithm(for: privateKey)

        guard let signer = algorithm.signer else {
            throw LocalKeyManagerError.signingNotSupported(algorithm: algorithm)
        }

        return try signer.sign(payload: payload, privateKey: privateKey)
    }

    public func getDeterministicAlias(key: Jwk) throws -> String {
        let alias: String

        if let keyIdentifier = key.keyIdentifier {
            alias = keyIdentifier
        } else {
            alias = try key.thumbprint()
        }

        return alias
    }

    // MARK: - Private

    private func getPrivateKey(keyAlias: String) throws -> Jwk {
        guard let privateKey = try keyStore.getPrivateKey(keyAlias: keyAlias) else {
            throw LocalKeyManagerError.keyNotFound
        }

        return privateKey
    }

    private func getSupportedCryptoAlgorithm(for jwk: Jwk) throws -> Algorithm {
        //        let algorithm = jwk.algorithm
        //        let curve = jwk.curve
        //
        //        switch (algorithm, curve) {
        //        case (.eddsa, .ed25519),
        //            (nil, .ed25519):
        //            return .ed25519
        //        case (.es256k, .secp256k1),
        //            (nil, .secp256k1),
        //            (.es256k, nil):
        //            return .es256k
        //        default:
        //            // TODO: This error should be renamed. It's not unknown, just unsupported.
        //            throw LocalKeyManagerError.unknownCryptoAlgorithm
        //        }
        throw LocalKeyManagerError.unknownCryptoAlgorithm
    }

}
