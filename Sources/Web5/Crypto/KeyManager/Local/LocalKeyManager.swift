import Foundation

public enum LocalKeyManagerError: Error {
    case unknownCryptoAlgorithm
    case keyNotFound
}

/// Protocol for a backing store which can store keys generated by a `LocalKeyManager`
public protocol LocalKeyStore {
    func getPrivateKey(keyAlias: String) throws -> Jwk?
    func setPrivateKey(_ privateKey: Jwk, keyAlias: String) throws
}

/// A KeyManager that generates and stores cryptographic keys locally on the device
public class LocalKeyManager: KeyManager {

    /// Exhaustive enum of all crypto algorithms supported by a `LocalKeyManager`
    public enum SupportedCryptoAlgorithm {
        /// EdDSA using the Ed25519 curve
        case ed25519
        /// ECDSA using the secp256k1 curve and SHA-256
        case es256k
    }

    /// Backing store to store generated keys
    let keyStore: LocalKeyStore

    /// Default initializer
    init(keyStore: LocalKeyStore) {
        self.keyStore = keyStore
    }

    // MARK: - KeyManager

    public func generatePrivateKey(algorithm: SupportedCryptoAlgorithm) throws -> String {
        let privateKey: Jwk

        switch algorithm {
        case .ed25519:
            privateKey = try EddsaAlgorithm.generateKey(.init(algorithm: .ed25519))
        case .es256k:
            privateKey = try EcdsaAlgorithm.generateKey(.init(algorithm: .es256k))
        }

        let keyAlias = try getDeterministicAlias(key: privateKey)
        try keyStore.setPrivateKey(privateKey, keyAlias: keyAlias)

        return keyAlias
    }

    public func getPublicKey(keyAlias: String) throws -> Jwk {
        let privateKey = try getPrivateKey(keyAlias: keyAlias)
        let algorithm = try getSupportedCryptoAlgorithm(for: privateKey)

        switch algorithm {
        case .ed25519:
            return try EddsaAlgorithm.computePublicKey(privateKey: privateKey)
        case .es256k:
            return try EcdsaAlgorithm.computePublicKey(privateKey: privateKey)
        }
    }

    public func sign<D>(keyAlias: String, payload: D) throws -> Data where D: DataProtocol {
        let privateKey = try getPrivateKey(keyAlias: keyAlias)
        let algorithm = try getSupportedCryptoAlgorithm(for: privateKey)

        // TODO: switches in this class are all duplicated. Consolidate.
        switch algorithm {
        case .ed25519:
            return try EddsaAlgorithm.sign(payload: payload, privateKey: privateKey)
        case .es256k:
            return try EcdsaAlgorithm.sign(payload: payload, privateKey: privateKey)
        }
    }

    public func getDeterministicAlias(key: Jwk) throws -> String {
        let alias: String

        if let keyIdentifier = key.keyIdentifier {
            alias = keyIdentifier
        } else {
            alias = try key.thumbprint()
        }

        return alias
    }

    // MARK: - Private

    private func getPrivateKey(keyAlias: String) throws -> Jwk {
        guard let privateKey = try keyStore.getPrivateKey(keyAlias: keyAlias) else {
            throw LocalKeyManagerError.keyNotFound
        }

        return privateKey
    }

    private func getSupportedCryptoAlgorithm(for jwk: Jwk) throws -> SupportedCryptoAlgorithm {
        let algorithm = jwk.algorithm
        let curve = jwk.curve

        switch (algorithm, curve) {
        case (.eddsa, .ed25519),
            (nil, .ed25519):
            return .ed25519
        case (.es256k, .secp256k1),
            (nil, .secp256k1),
            (.es256k, nil):
            return .es256k
        default:
            // TODO: This error shoudl be renamed. It's not unknown, just unsupported.
            throw LocalKeyManagerError.unknownCryptoAlgorithm
        }

    }

}
